package codegeneration;

import scanner.Type;
import symboltable.SymbolTable;
import syntaxtree.*;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Bob Laskowski,
 * Compilers II,
 * Dr. Erik Steinmetz,
 * April 27th, 2017
 * <p>
 * This class will create assembly code for a pascal program.
 *
 * @author Bob Laskowski
 */
public class CodeGeneration {

    ///////////////////////////////
    //    Instance Variables
    ///////////////////////////////

    private SymbolTable stc;
    private ProgramNode program;
    private int currentReg;
    private int loopNum;
    private int ifNum;

    ///////////////////////////////
    //       Constructors
    ///////////////////////////////

    /**
     * Default constructor for creating a code generation object. Defines local ints to 0 and symbol table and program
     * node to arguments passed in.
     *
     * @param pro  ProgramNode generated by the parser
     * @param symb Symbol table for the program
     */
    public CodeGeneration(ProgramNode pro, SymbolTable symb) {
        program = pro;
        stc = symb;
        currentReg = 0;
        loopNum = 0;
        ifNum = 0;
    }

    ///////////////////////////////
    //       Methods
    ///////////////////////////////

    /**
     * Starts the code from the root node by writing the outline of the
     * assembly code, and telling the root node to write its answer into $s0.
     *
     * @return A String of the assembly code.
     */
    public String generateCode() {
        StringBuilder code = new StringBuilder();
        code.append(".data\n");
        code.append("__newline__:\t.asciiz\t\"\\n\"\n");
        code.append("__input__:\t.asciiz\t\"input: \"\n");

        for (VariableNode var : program.getVariables().getVars()) {
            if (stc.isArrayName(var.getName())) {
                int aryLength = stc.get(var.getName()).getArrayLength();
                code.append(var.getName()).append(":\t.word\t");
                for (int i = 0; i < aryLength - 1; i++) {
                    code.append("0, ");
                }
                code.append("0\n");
            } else {
                code.append(var.getName()).append(":\t.word\t0\n");
                stc.get(var.getName()).setMemAddress(var.getName());
            }
        }

        code.append("\n.text\n");
        code.append("main:\n");

        // push all s registers, ra
        code.append(pushToStack());

        // write main code
        for (StatementNode state : program.getMain().getStatements()) {
            code.append(writeStatement(state, "$s" + currentReg));
        }

        // pop s registers, ra
        code.append(popFromStack());

        // write function code
        for (SubProgramNode subNode : program.getFunctions().getProcs()) {
            code.append(writeSubProgram(subNode));
        }

        return (code.toString());
    }

    /**
     * Generates the assembly code for a function
     *
     * @param node SubProgramNode from the parser
     * @return The code which executes this operation
     */
    private String writeSubProgram(SubProgramNode node) {
        StringBuilder code = new StringBuilder();
        code.append("\n# Function\n");
        code.append(node.getName()).append(":\n");
        // get the local table for the function
        HashMap<String, SymbolTable.Symbol> localTable = stc.getLocalTable(node.getName());
        int offset = 0;
        if (localTable != null) offset = localTable.size();
        // add local table to current symbol table stack
        stc.pushLocalTable(localTable);

        code.append(pushToStack());
        // move stack pointer to fp
        code.append("move\t$fp,\t$sp\n");
        code.append("addi\t$sp,\t$sp,\t-").append(offset * 4).append("\n");

        code.append(assignMemoryAddress(node));

        for (StatementNode state : node.getMain().getStatements()) {
            String reg = "$s" + currentReg;
            code.append(writeStatement(state, reg));
        }

        // add return type for function
        if (stc.isFunctionName(node.getName())) {
            code.append("lw\t$v0,\t").append(stc.get(node.getName()).getMemAddress()).append("\n");
        }

        code.append("addi\t$sp,\t$sp,\t").append(offset * 4).append("\n");
        code.append("move\t$sp,\t$fp\n");
        code.append(popFromStack());

        stc.removeScope();
        return code.toString();
    }

    /**
     * Generates the assembly code for a Statement
     *
     * @param node Statement Node from the parser
     * @param reg  The register we are working with
     * @return The assembly code which executes this operation
     */
    private String writeStatement(StatementNode node, String reg) {
        StringBuilder code = new StringBuilder();
        if (node instanceof AssignmentStatementNode) {
            code.append(writeAssignment((AssignmentStatementNode) node, reg));
        } else if (node instanceof IfStatementNode) {
            code.append(writeIfStatement((IfStatementNode) node, reg));
        } else if (node instanceof ProcedureStatementNode) {
            // implement procedure stuff
            code.append(writeProcedureStatement((ProcedureStatementNode) node));
        } else if (node instanceof WhileStatementNode) {
            code.append(writeWhile((WhileStatementNode) node, reg));
        } else if (node instanceof CompoundStatementNode) {
            for (StatementNode state : ((CompoundStatementNode) node).getStatements()) {
                code.append(writeStatement(state, reg));
            }
        } else if (node instanceof WriteNode) {
            code.append(writeWrite((WriteNode) node, reg));
        } else if (node instanceof ReadNode) {
            code.append(writeRead((ReadNode) node));
        } else code.append("ERROR!!!");
        return code.toString();
    }

    /**
     * Write the code for a procedure statement call
     *
     * @param node The ProcedureStatementNode to pass in
     * @return The assembly code which executes this operation
     */
    private String writeProcedureStatement(ProcedureStatementNode node) {
        StringBuilder code = new StringBuilder();
        code.append("\n#Procedure Call\n");

        int argumentNumber = 0;
        for (ExpressionNode exp : node.getArgs()) {
            String register = "$a" + argumentNumber++;
            code.append(writeExpression(exp, register));
        }
        code.append("jal\t").append(node.getName()).append("\n");

        return code.toString();
    }

    /**
     * Generates assembly code for a while statement
     *
     * @param node WhileStatementNode from parser
     * @param reg  The register we are working with
     * @return The assembly code which executes this operation
     */
    private String writeWhile(WhileStatementNode node, String reg) {
        StringBuilder code = new StringBuilder();
        code.append("\n# while loop\n");

        code.append("while").append(loopNum).append(":\n");
        code.append(writeExpression(node.getTest(), reg));
        code.append("endWhile").append(loopNum).append("\n");

        reg = "$s" + ++currentReg;
        code.append(writeStatement(node.getDo(), reg));

        code.append("j\twhile").append(loopNum).append("\n");
        code.append("endWhile").append(loopNum).append(":\n");

        currentReg--;
        return code.toString();
    }

    /**
     * Generates assembly code for an if statement
     *
     * @param node IfStatementNode from parser
     * @param reg  The register we are working with
     * @return The assembly code which executes this operation
     */
    private String writeIfStatement(IfStatementNode node, String reg) {
        StringBuilder code = new StringBuilder();
        code.append("\n#If statement\n");

        // If code folding has turned the expression to evaluate into a 0 or 1
        if (node.getTest() instanceof ValueNode) {
            code.append(writeExpression(node.getTest(), reg));
            String otherReg = "$s" + ++currentReg;
            code.append("li\t").append(otherReg).append(",\t").append("1\n");
            code.append("bne\t").append(reg).append(",\t").append(otherReg).append(",\t");
            code.append("else").append(ifNum).append("\n");
        } else
            code.append(writeOperation((OperationNode) node.getTest(), reg)).append("else").append(ifNum).append("\n");

        code.append("\n# then\n");
        reg = "$s" + currentReg++;
        code.append(writeStatement(node.getThen(), reg));
        code.append("j\tendIf").append(ifNum).append("\n");

        code.append("\n# else\n");
        reg = "$s" + currentReg++;
        code.append("else").append(ifNum).append(":\n");
        code.append(writeStatement(node.getElse(), reg));
        code.append("endIf").append(ifNum).append(":\n");

        currentReg -= 2;
        return code.toString();
    }

    /**
     * Generates assembly code an expression
     *
     * @param node ExpressionNode from parser
     * @param reg  The register we are working with
     * @return The assembly code which executes this operation
     */
    private String writeExpression(ExpressionNode node, String reg) {
        StringBuilder code = new StringBuilder();
        code.append("\n#Expression\n");
        if (node instanceof ValueNode) {
            code.append(writeValue((ValueNode) node, reg));
        } else if (node instanceof OperationNode) {
            code.append(writeOperation((OperationNode) node, reg));
        } else if (node instanceof ArrayNode) {
            // implement array stuff
        } else if (node instanceof FunctionNode) {
            code.append("\n# Function call\n");
            int numArgs = ((FunctionNode) node).getArgs().size();
            for (int i = 0; i < numArgs; i++) {
                String funcReg = "$a" + i;
                code.append(writeExpression(((FunctionNode) node).getArgs().get(i), funcReg));
            }

            code.append("jal\t").append(((FunctionNode) node).getName()).append("\n");

            code.append("move\t").append(reg).append(",\t$v0\n");

        } else if (node instanceof VariableNode) {
            String var = stc.get(((VariableNode) node).getName()).getMemAddress();
            code.append("lw\t").append(reg).append(",\t").append(var).append("\n");
        } else code.append("ERROR!!!");
        return code.toString();
    }

    /**
     * Generates assembly code for assignment operation
     *
     * @param node AssignmentStatementNode from parser
     * @param reg  The register we are working with
     * @return The assembly code which executes this operation
     */
    private String writeAssignment(AssignmentStatementNode node, String reg) {
        return "\n#Assignment\n" + writeExpression(node.getExpression(), reg) + "sw\t" + reg + ",\t" + stc.get(node.getLValue().getName()).getMemAddress() + "\n";
    }

    /**
     * Writes code for an operations node.
     * The code is written by gathering the child nodes' answers into
     * a pair of registers, and then executing the op on those registers,
     * placing the result in the given result register.
     *
     * @param opNode         The operation node to perform.
     * @param resultRegister The register in which to put the result.
     * @return The code which executes this operation.
     */
    private String writeOperation(OperationNode opNode, String resultRegister) {
        StringBuilder code = new StringBuilder();
        ExpressionNode left = opNode.getLeft();
        String leftRegister = "$s" + currentReg++;
        code.append(writeExpression(left, leftRegister));
        ExpressionNode right = opNode.getRight();
        String rightRegister = "$s" + currentReg++;
        code.append(writeExpression(right, rightRegister));
        Type kindOfOp = opNode.getOperation();
        if (kindOfOp == Type.PLUS) {
            // add resultregister, left, right
            code.append("add\t").append(resultRegister).append(",\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
        } else if (kindOfOp == Type.MINUS) {
            // add resultregister, left, right
            code.append("sub\t").append(resultRegister).append(",\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
        } else if (kindOfOp == Type.ASTERISK) {
            code.append("mult\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
            code.append("mflo\t").append(resultRegister).append("\n");
        } else if (kindOfOp == Type.FSLASH) {
            // implement floating point division?
            code.append("div\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
            code.append("mflo\t").append(resultRegister).append("\n");
        } else if (kindOfOp == Type.DIV) {
            code.append("div\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
            code.append("mflo\t").append(resultRegister).append("\n");
        } else if (kindOfOp == Type.MOD) {
            code.append("div\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
            code.append("mfhi\t").append(resultRegister).append("\n");
        } else if (kindOfOp == Type.AND) {
            // Note that this is a bitwise and
            code.append("and\t").append(resultRegister).append(",\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
        } else if (kindOfOp == Type.OR) {
            // Note that this is bitwise or
            code.append("or\t").append(resultRegister).append(",\t").append(leftRegister).append(",\t").append(rightRegister).append("\n");
        } else if (kindOfOp == Type.LTHAN) {
            // branch >=
            code.append("bge\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        } else if (kindOfOp == Type.GTHAN) {
            // branch <=
            code.append("ble\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        } else if (kindOfOp == Type.LTHANEQ) {
            // branch >
            code.append("bgt\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        } else if (kindOfOp == Type.GTHANEQ) {
            // branch <
            code.append("blt\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        } else if (kindOfOp == Type.EQUAL) {
            // branch !=
            code.append("bne\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        } else if (kindOfOp == Type.NOTEQ) {
            // branch ==
            code.append("beq\t").append(leftRegister).append(",\t").append(rightRegister).append(",\t");
        }
        this.currentReg -= 2;
        return code.toString();
    }

    ///////////////////////////////
    //       Utility Methods
    ///////////////////////////////

    /**
     * Assigns the memory address property in the symbol table to the name of the variable for global variables or the
     * stack pointer offset for local variables.
     *
     * @param node SubProgramNode from the parser
     * @return The code which executes this operation
     */
    private String assignMemoryAddress(SubProgramNode node) {
        StringBuilder code = new StringBuilder();
        ArrayList<VariableNode> vars = node.getVariables().getVars();
        ArrayList<VariableNode> args = node.getArgs();
        int numArgs = args.size();
        int offset = 0;

        for (VariableNode var : vars) {
            String reg = offset + "($sp)";
            stc.get(var.getName()).setMemAddress(reg);
            offset += 4;
        }

        for (int i = 0; i < numArgs; i++) {
            String reg = offset + "($sp)";
            stc.get(args.get(i).getName()).setMemAddress(reg);
            code.append("sw\t$a").append(i).append(",\t").append(reg).append("\n");
            offset += 4;
        }
        return code.toString();
    }

    /**
     * Writes code for a value node.
     * The code is written by executing an add immediate with the value
     * into the destination register.
     * Writes code that looks like  addi $reg, $zero, value
     *
     * @param valNode        The node containing the value.
     * @param resultRegister The register in which to put the value.
     * @return The code which executes this value node.
     */
    private String writeValue(ValueNode valNode, String resultRegister) {
        String value = valNode.getAttribute();
        return "li\t" + resultRegister + ",\t" + value + "\n";
    }

    /**
     * Push all the $s registers, $fp and $sp to the stack
     *
     * @return The assembly code which executes this operation
     */
    private String pushToStack() {
        StringBuilder code = new StringBuilder();
        code.append("\n#Push to stack\n");
        code.append("addi\t$sp,\t$sp,\t-");
        code.append(8 * 4 + 8);
        code.append('\n');

        for (int i = 8 - 1; i >= 0; i--) {
            code.append("sw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }

        code.append("sw\t$fp,\t4($sp)\n");
        code.append("sw\t$ra,\t0($sp)\n");

        return code.toString();
    }

    /**
     * Pop all the $s registers, $fp and $sp from the stack
     *
     * @return The assembly code which executes this operation
     */
    private String popFromStack() {
        StringBuilder code = new StringBuilder();
        code.append("\n#Restore from stack\n");

        for (int i = 8 - 1; i >= 0; i--) {
            code.append("lw\t").append("$s").append(i).append(",\t").append(4 * (i + 2)).append("($sp)\n");
        }
        code.append("lw\t$fp,\t4($sp)\n");
        code.append("lw\t$ra,\t0($sp)\n");
        code.append("addi\t$sp,\t$sp,\t");
        code.append((8 * 4) + 8).append("\n");
        code.append("jr\t$ra\n");
        return code.toString();
    }

    /**
     * Write code for "write" function for displaying to console
     *
     * @param write WriteNode from parser
     * @param reg   The register we are working with
     * @return Assembly code generated for this operation
     */
    private String writeWrite(WriteNode write, String reg) {
        return "\n#Syscall\n" + writeExpression(write.getData(), reg) + "addi\t$v0,\t$zero,\t1\n" + "add\t$a0,\t" + reg + ",\t$zero\n" + "syscall\n" + "li\t$v0,\t4" + "\nla\t$a0, __newline__\n" + "syscall\n";
    }

    /**
     * Write code for "read" function for taking in input from console
     *
     * @param node ReadNode from parser
     * @return Assembly code generated for this operation
     */
    private String writeRead(ReadNode node) {
        StringBuilder code = new StringBuilder();
        code.append("\n# Read\n");

        code.append("li\t$v0,\t4");
        code.append("\nla\t$a0,\t__input__\n");
        code.append("syscall\n");

        Type retType = stc.get(node.getId().getName()).getType();

        if (retType == Type.INTEGER) {
            code.append("li\t$v0,\t5\n");
            code.append("syscall\n");
            code.append("sw\t$v0,\t").append(node.getId().getName()).append("\n");
        } else if (retType == Type.REAL) {
            // do floating point stuff
        }

        return code.toString();
    }
}
